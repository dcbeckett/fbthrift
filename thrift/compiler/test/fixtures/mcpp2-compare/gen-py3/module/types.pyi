#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

import folly.iobuf as __iobuf
import thrift.py3.types
import thrift.py3.exceptions
from thrift.py3.types import NOTSET, NOTSETTYPE
from thrift.py3.serializer import Protocol
import typing as _typing

import sys
import itertools
import includes.types as _includes_types


__property__ = property


class MyEnumA(thrift.py3.types.Enum):
    fieldA: MyEnumA = ...
    fieldB: MyEnumA = ...
    fieldC: MyEnumA = ...


class AnnotatedEnum(thrift.py3.types.Enum):
    FIELDA: AnnotatedEnum = ...
    FIELDB: AnnotatedEnum = ...
    FIELDC: AnnotatedEnum = ...


class AnnotatedEnum2(thrift.py3.types.Enum):
    FIELDA: AnnotatedEnum2 = ...
    FIELDB: AnnotatedEnum2 = ...
    FIELDC: AnnotatedEnum2 = ...


class MyEnumB(thrift.py3.types.Enum):
    AField: MyEnumB = ...


class Empty(thrift.py3.types.Struct, _typing.Hashable, _typing.Iterable[_typing.Tuple[str, _typing.Any]]):
    def __init__(
        self, 
    ) -> None: ...

    def __call__(
        self, 
    ) -> Empty: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['Empty'], bytes]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'Empty') -> bool: ...
    def __gt__(self, other: 'Empty') -> bool: ...
    def __le__(self, other: 'Empty') -> bool: ...
    def __ge__(self, other: 'Empty') -> bool: ...



class ASimpleStruct(thrift.py3.types.Struct, _typing.Hashable, _typing.Iterable[_typing.Tuple[str, _typing.Any]]):
    def __init__(
        self, *,
        boolField: _typing.Optional[int]=None
    ) -> None: ...

    def __call__(
        self, *,
        boolField: _typing.Union[int, NOTSETTYPE, None]=NOTSET
    ) -> ASimpleStruct: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['ASimpleStruct'], bytes]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...

    @__property__
    def boolField(self) -> int: ...


class ASimpleStructNoexcept(thrift.py3.types.Struct, _typing.Hashable, _typing.Iterable[_typing.Tuple[str, _typing.Any]]):
    def __init__(
        self, *,
        boolField: _typing.Optional[int]=None
    ) -> None: ...

    def __call__(
        self, *,
        boolField: _typing.Union[int, NOTSETTYPE, None]=NOTSET
    ) -> ASimpleStructNoexcept: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['ASimpleStructNoexcept'], bytes]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'ASimpleStructNoexcept') -> bool: ...
    def __gt__(self, other: 'ASimpleStructNoexcept') -> bool: ...
    def __le__(self, other: 'ASimpleStructNoexcept') -> bool: ...
    def __ge__(self, other: 'ASimpleStructNoexcept') -> bool: ...

    @__property__
    def boolField(self) -> int: ...


class MyStruct(thrift.py3.types.Struct, _typing.Hashable, _typing.Iterable[_typing.Tuple[str, _typing.Any]]):
    def __init__(
        self, *,
        MyBoolField: _typing.Optional[bool]=None,
        MyIntField: _typing.Optional[int]=None,
        MyStringField: _typing.Optional[str]=None,
        MyStringField2: _typing.Optional[str]=None,
        MyBinaryField: _typing.Optional[bytes]=None,
        MyBinaryField2: _typing.Optional[bytes]=None,
        MyBinaryField3: bytes,
        MyBinaryListField4: _typing.Optional[_typing.Sequence[bytes]]=None,
        MyMapEnumAndInt: _typing.Optional[_typing.Mapping[MyEnumA, str]]=None
    ) -> None: ...

    def __call__(
        self, *,
        MyBoolField: _typing.Union[bool, NOTSETTYPE, None]=NOTSET,
        MyIntField: _typing.Union[int, NOTSETTYPE, None]=NOTSET,
        MyStringField: _typing.Union[str, NOTSETTYPE, None]=NOTSET,
        MyStringField2: _typing.Union[str, NOTSETTYPE, None]=NOTSET,
        MyBinaryField: _typing.Union[bytes, NOTSETTYPE, None]=NOTSET,
        MyBinaryField2: _typing.Union[bytes, NOTSETTYPE, None]=NOTSET,
        MyBinaryField3: _typing.Union[bytes, NOTSETTYPE]=NOTSET,
        MyBinaryListField4: _typing.Union[_typing.Sequence[bytes], NOTSETTYPE, None]=NOTSET,
        MyMapEnumAndInt: _typing.Union[_typing.Mapping[MyEnumA, str], NOTSETTYPE, None]=NOTSET
    ) -> MyStruct: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['MyStruct'], bytes]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'MyStruct') -> bool: ...
    def __gt__(self, other: 'MyStruct') -> bool: ...
    def __le__(self, other: 'MyStruct') -> bool: ...
    def __ge__(self, other: 'MyStruct') -> bool: ...

    @__property__
    def MyBoolField(self) -> bool: ...
    @__property__
    def MyIntField(self) -> int: ...
    @__property__
    def MyStringField(self) -> str: ...
    @__property__
    def MyStringField2(self) -> str: ...
    @__property__
    def MyBinaryField(self) -> bytes: ...
    @__property__
    def MyBinaryField2(self) -> _typing.Optional[bytes]: ...
    @__property__
    def MyBinaryField3(self) -> bytes: ...
    @__property__
    def MyBinaryListField4(self) -> _typing.Sequence[bytes]: ...
    @__property__
    def MyMapEnumAndInt(self) -> _typing.Mapping[MyEnumA, str]: ...


class SimpleUnion(thrift.py3.types.Union, _typing.Hashable):
    def __init__(
        self, *,
        intValue: _typing.Optional[int]=None,
        stringValue: _typing.Optional[str]=None
    ) -> None: ...

    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'SimpleUnion') -> bool: ...
    def __gt__(self, other: 'SimpleUnion') -> bool: ...
    def __le__(self, other: 'SimpleUnion') -> bool: ...
    def __ge__(self, other: 'SimpleUnion') -> bool: ...

    @__property__
    def intValue(self) -> int: ...
    @__property__
    def stringValue(self) -> str: ...
    class Type(thrift.py3.types.Enum):
        EMPTY: SimpleUnion.Type = ...
        intValue: SimpleUnion.Type = ...
        stringValue: SimpleUnion.Type = ...

    @staticmethod
    def fromValue(value: _typing.Union[None, int, str]) -> SimpleUnion: ...
    @__property__
    def value(self) -> _typing.Union[None, int, str]: ...
    @__property__
    def type(self) -> "SimpleUnion.Type": ...
    def get_type(self) -> "SimpleUnion.Type": ...


class ComplexUnion(thrift.py3.types.Union, _typing.Hashable):
    def __init__(
        self, *,
        intValue: _typing.Optional[int]=None,
        opt_intValue: _typing.Optional[int]=None,
        stringValue: _typing.Optional[str]=None,
        opt_stringValue: _typing.Optional[str]=None,
        intValue2: _typing.Optional[int]=None,
        intValue3: _typing.Optional[int]=None,
        doubelValue: _typing.Optional[float]=None,
        boolValue: _typing.Optional[bool]=None,
        union_list: _typing.Optional[_typing.Sequence[int]]=None,
        union_set: _typing.Optional[_typing.AbstractSet[int]]=None,
        union_map: _typing.Optional[_typing.Mapping[str, int]]=None,
        opt_union_map: _typing.Optional[_typing.Mapping[str, int]]=None,
        enum_field: _typing.Optional[MyEnumA]=None,
        enum_container: _typing.Optional[_typing.Sequence[MyEnumA]]=None,
        a_struct: _typing.Optional['MyStruct']=None,
        a_set_struct: _typing.Optional[_typing.AbstractSet['MyStruct']]=None,
        a_union: _typing.Optional['SimpleUnion']=None,
        opt_a_union: _typing.Optional['SimpleUnion']=None,
        a_union_list: _typing.Optional[_typing.Sequence['SimpleUnion']]=None,
        a_union_typedef: _typing.Optional[_typing.AbstractSet['SimpleUnion']]=None,
        a_union_typedef_list: _typing.Optional[_typing.Sequence[_typing.AbstractSet['SimpleUnion']]]=None,
        MyBinaryField: _typing.Optional[bytes]=None,
        MyBinaryField2: _typing.Optional[bytes]=None,
        MyBinaryListField4: _typing.Optional[_typing.Sequence[bytes]]=None,
        ref_field: _typing.Optional['MyStruct']=None,
        ref_field2: _typing.Optional['MyStruct']=None,
        excp_field: _typing.Optional['AnException']=None
    ) -> None: ...

    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'ComplexUnion') -> bool: ...
    def __gt__(self, other: 'ComplexUnion') -> bool: ...
    def __le__(self, other: 'ComplexUnion') -> bool: ...
    def __ge__(self, other: 'ComplexUnion') -> bool: ...

    @__property__
    def intValue(self) -> int: ...
    @__property__
    def opt_intValue(self) -> _typing.Optional[int]: ...
    @__property__
    def stringValue(self) -> str: ...
    @__property__
    def opt_stringValue(self) -> _typing.Optional[str]: ...
    @__property__
    def intValue2(self) -> int: ...
    @__property__
    def intValue3(self) -> int: ...
    @__property__
    def doubelValue(self) -> float: ...
    @__property__
    def boolValue(self) -> bool: ...
    @__property__
    def union_list(self) -> _typing.Sequence[int]: ...
    @__property__
    def union_set(self) -> _typing.AbstractSet[int]: ...
    @__property__
    def union_map(self) -> _typing.Mapping[str, int]: ...
    @__property__
    def opt_union_map(self) -> _typing.Optional[_typing.Mapping[str, int]]: ...
    @__property__
    def enum_field(self) -> MyEnumA: ...
    @__property__
    def enum_container(self) -> _typing.Sequence[MyEnumA]: ...
    @__property__
    def a_struct(self) -> 'MyStruct': ...
    @__property__
    def a_set_struct(self) -> _typing.AbstractSet['MyStruct']: ...
    @__property__
    def a_union(self) -> 'SimpleUnion': ...
    @__property__
    def opt_a_union(self) -> _typing.Optional['SimpleUnion']: ...
    @__property__
    def a_union_list(self) -> _typing.Sequence['SimpleUnion']: ...
    @__property__
    def a_union_typedef(self) -> _typing.AbstractSet['SimpleUnion']: ...
    @__property__
    def a_union_typedef_list(self) -> _typing.Sequence[_typing.AbstractSet['SimpleUnion']]: ...
    @__property__
    def MyBinaryField(self) -> bytes: ...
    @__property__
    def MyBinaryField2(self) -> _typing.Optional[bytes]: ...
    @__property__
    def MyBinaryListField4(self) -> _typing.Sequence[bytes]: ...
    @__property__
    def ref_field(self) -> _typing.Optional['MyStruct']: ...
    @__property__
    def ref_field2(self) -> _typing.Optional['MyStruct']: ...
    @__property__
    def excp_field(self) -> 'AnException': ...
    class Type(thrift.py3.types.Enum):
        EMPTY: ComplexUnion.Type = ...
        intValue: ComplexUnion.Type = ...
        opt_intValue: ComplexUnion.Type = ...
        stringValue: ComplexUnion.Type = ...
        opt_stringValue: ComplexUnion.Type = ...
        intValue2: ComplexUnion.Type = ...
        intValue3: ComplexUnion.Type = ...
        doubelValue: ComplexUnion.Type = ...
        boolValue: ComplexUnion.Type = ...
        union_list: ComplexUnion.Type = ...
        union_set: ComplexUnion.Type = ...
        union_map: ComplexUnion.Type = ...
        opt_union_map: ComplexUnion.Type = ...
        enum_field: ComplexUnion.Type = ...
        enum_container: ComplexUnion.Type = ...
        a_struct: ComplexUnion.Type = ...
        a_set_struct: ComplexUnion.Type = ...
        a_union: ComplexUnion.Type = ...
        opt_a_union: ComplexUnion.Type = ...
        a_union_list: ComplexUnion.Type = ...
        a_union_typedef: ComplexUnion.Type = ...
        a_union_typedef_list: ComplexUnion.Type = ...
        MyBinaryField: ComplexUnion.Type = ...
        MyBinaryField2: ComplexUnion.Type = ...
        MyBinaryListField4: ComplexUnion.Type = ...
        ref_field: ComplexUnion.Type = ...
        ref_field2: ComplexUnion.Type = ...
        excp_field: ComplexUnion.Type = ...

    @staticmethod
    def fromValue(value: _typing.Union[None, int, int, str, str, int, int, float, bool, _typing.Sequence[int], _typing.AbstractSet[int], _typing.Mapping[str, int], _typing.Mapping[str, int], MyEnumA, _typing.Sequence[MyEnumA], 'MyStruct', _typing.AbstractSet['MyStruct'], 'SimpleUnion', 'SimpleUnion', _typing.Sequence['SimpleUnion'], _typing.AbstractSet['SimpleUnion'], _typing.Sequence[_typing.AbstractSet['SimpleUnion']], bytes, bytes, _typing.Sequence[bytes], 'MyStruct', 'MyStruct', 'AnException']) -> ComplexUnion: ...
    @__property__
    def value(self) -> _typing.Union[None, int, int, str, str, int, int, float, bool, _typing.Sequence[int], _typing.AbstractSet[int], _typing.Mapping[str, int], _typing.Mapping[str, int], MyEnumA, _typing.Sequence[MyEnumA], 'MyStruct', _typing.AbstractSet['MyStruct'], 'SimpleUnion', 'SimpleUnion', _typing.Sequence['SimpleUnion'], _typing.AbstractSet['SimpleUnion'], _typing.Sequence[_typing.AbstractSet['SimpleUnion']], bytes, bytes, _typing.Sequence[bytes], 'MyStruct', 'MyStruct', 'AnException']: ...
    @__property__
    def type(self) -> "ComplexUnion.Type": ...
    def get_type(self) -> "ComplexUnion.Type": ...


class AnException(thrift.py3.exceptions.Error, _typing.Hashable, _typing.Iterable[_typing.Tuple[str, _typing.Any]]):
    def __init__(
        self, *,
        code: _typing.Optional[int]=None,
        req_code: int,
        message2: _typing.Optional[str]=None,
        req_message: str,
        exception_list: _typing.Optional[_typing.Sequence[int]]=None,
        exception_set: _typing.Optional[_typing.AbstractSet[int]]=None,
        exception_map: _typing.Optional[_typing.Mapping[str, int]]=None,
        req_exception_map: _typing.Mapping[str, int],
        enum_field: _typing.Optional[MyEnumA]=None,
        enum_container: _typing.Optional[_typing.Sequence[MyEnumA]]=None,
        a_struct: _typing.Optional['MyStruct']=None,
        a_set_struct: _typing.Optional[_typing.AbstractSet['MyStruct']]=None,
        a_union_list: _typing.Optional[_typing.Sequence['SimpleUnion']]=None,
        union_typedef: _typing.Optional[_typing.AbstractSet['SimpleUnion']]=None,
        a_union_typedef_list: _typing.Optional[_typing.Sequence[_typing.AbstractSet['SimpleUnion']]]=None
    ) -> None: ...

    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'AnException') -> bool: ...
    def __gt__(self, other: 'AnException') -> bool: ...
    def __le__(self, other: 'AnException') -> bool: ...
    def __ge__(self, other: 'AnException') -> bool: ...

    @__property__
    def code(self) -> int: ...
    @__property__
    def req_code(self) -> int: ...
    @__property__
    def message2(self) -> str: ...
    @__property__
    def req_message(self) -> str: ...
    @__property__
    def exception_list(self) -> _typing.Sequence[int]: ...
    @__property__
    def exception_set(self) -> _typing.AbstractSet[int]: ...
    @__property__
    def exception_map(self) -> _typing.Mapping[str, int]: ...
    @__property__
    def req_exception_map(self) -> _typing.Mapping[str, int]: ...
    @__property__
    def enum_field(self) -> MyEnumA: ...
    @__property__
    def enum_container(self) -> _typing.Sequence[MyEnumA]: ...
    @__property__
    def a_struct(self) -> 'MyStruct': ...
    @__property__
    def a_set_struct(self) -> _typing.AbstractSet['MyStruct']: ...
    @__property__
    def a_union_list(self) -> _typing.Sequence['SimpleUnion']: ...
    @__property__
    def union_typedef(self) -> _typing.AbstractSet['SimpleUnion']: ...
    @__property__
    def a_union_typedef_list(self) -> _typing.Sequence[_typing.AbstractSet['SimpleUnion']]: ...


class AnotherException(thrift.py3.exceptions.Error, _typing.Hashable, _typing.Iterable[_typing.Tuple[str, _typing.Any]]):
    def __init__(
        self, *,
        code: _typing.Optional[int]=None,
        req_code: int,
        message: _typing.Optional[str]=None
    ) -> None: ...

    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'AnotherException') -> bool: ...
    def __gt__(self, other: 'AnotherException') -> bool: ...
    def __le__(self, other: 'AnotherException') -> bool: ...
    def __ge__(self, other: 'AnotherException') -> bool: ...

    @__property__
    def code(self) -> int: ...
    @__property__
    def req_code(self) -> int: ...
    @__property__
    def message(self) -> str: ...


class containerStruct(thrift.py3.types.Struct, _typing.Hashable, _typing.Iterable[_typing.Tuple[str, _typing.Any]]):
    def __init__(
        self, *,
        fieldA: _typing.Optional[bool]=None,
        req_fieldA: bool,
        opt_fieldA: _typing.Optional[bool]=None,
        fieldB: _typing.Optional[_typing.Mapping[str, bool]]=None,
        req_fieldB: _typing.Mapping[str, bool],
        opt_fieldB: _typing.Optional[_typing.Mapping[str, bool]]=None,
        fieldC: _typing.Optional[_typing.AbstractSet[int]]=None,
        req_fieldC: _typing.Optional[_typing.AbstractSet[int]]=None,
        opt_fieldC: _typing.Optional[_typing.AbstractSet[int]]=None,
        fieldD: _typing.Optional[str]=None,
        fieldE: _typing.Optional[str]=None,
        req_fieldE: _typing.Optional[str]=None,
        opt_fieldE: _typing.Optional[str]=None,
        fieldF: _typing.Optional[_typing.Sequence[_typing.Sequence[int]]]=None,
        fieldG: _typing.Optional[_typing.Mapping[str, _typing.Mapping[str, _typing.Mapping[str, int]]]]=None,
        fieldH: _typing.Optional[_typing.Sequence[_typing.AbstractSet[int]]]=None,
        fieldI: _typing.Optional[bool]=None,
        fieldJ: _typing.Optional[_typing.Mapping[str, _typing.Sequence[int]]]=None,
        fieldK: _typing.Optional[_typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]]]=None,
        fieldL: _typing.Optional[_typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]]=None,
        fieldM: _typing.Optional[_typing.Mapping[_typing.AbstractSet[_typing.Sequence[int]], _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]]]=None,
        fieldN: _typing.Optional[int]=None,
        fieldO: _typing.Optional[_typing.Sequence[_typing.Mapping['Empty', 'MyStruct']]]=None,
        fieldP: _typing.Optional[_typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Mapping['Empty', 'MyStruct']]]]]=None,
        fieldQ: _typing.Optional[MyEnumA]=None,
        fieldR: _typing.Optional[MyEnumA]=None,
        req_fieldR: _typing.Optional[MyEnumA]=None,
        opt_fieldR: _typing.Optional[MyEnumA]=None,
        fieldS: _typing.Optional[MyEnumA]=None,
        fieldT: _typing.Optional[_typing.Sequence[MyEnumA]]=None,
        fieldU: _typing.Optional[_typing.Sequence[MyEnumA]]=None,
        fieldV: _typing.Optional['MyStruct']=None,
        req_fieldV: 'MyStruct',
        opt_fieldV: _typing.Optional['MyStruct']=None,
        fieldW: _typing.Optional[_typing.AbstractSet['MyStruct']]=None,
        fieldX: _typing.Optional['ComplexUnion']=None,
        req_fieldX: 'ComplexUnion',
        opt_fieldX: _typing.Optional['ComplexUnion']=None,
        fieldY: _typing.Optional[_typing.Sequence['ComplexUnion']]=None,
        fieldZ: _typing.Optional[_typing.AbstractSet['SimpleUnion']]=None,
        fieldAA: _typing.Optional[_typing.Sequence[_typing.AbstractSet['SimpleUnion']]]=None,
        fieldAB: _typing.Optional[_typing.Mapping[float, int]]=None,
        fieldAC: _typing.Optional[MyEnumB]=None,
        fieldAD: _typing.Optional[_includes_types.AnEnum]=None,
        fieldAE: _typing.Optional[_typing.Mapping[str, int]]=None,
        fieldSD: _typing.Optional[str]=None
    ) -> None: ...

    def __call__(
        self, *,
        fieldA: _typing.Union[bool, NOTSETTYPE, None]=NOTSET,
        req_fieldA: _typing.Union[bool, NOTSETTYPE]=NOTSET,
        opt_fieldA: _typing.Union[bool, NOTSETTYPE, None]=NOTSET,
        fieldB: _typing.Union[_typing.Mapping[str, bool], NOTSETTYPE, None]=NOTSET,
        req_fieldB: _typing.Union[_typing.Mapping[str, bool], NOTSETTYPE]=NOTSET,
        opt_fieldB: _typing.Union[_typing.Mapping[str, bool], NOTSETTYPE, None]=NOTSET,
        fieldC: _typing.Union[_typing.AbstractSet[int], NOTSETTYPE, None]=NOTSET,
        req_fieldC: _typing.Union[_typing.AbstractSet[int], NOTSETTYPE, None]=NOTSET,
        opt_fieldC: _typing.Union[_typing.AbstractSet[int], NOTSETTYPE, None]=NOTSET,
        fieldD: _typing.Union[str, NOTSETTYPE, None]=NOTSET,
        fieldE: _typing.Union[str, NOTSETTYPE, None]=NOTSET,
        req_fieldE: _typing.Union[str, NOTSETTYPE, None]=NOTSET,
        opt_fieldE: _typing.Union[str, NOTSETTYPE, None]=NOTSET,
        fieldF: _typing.Union[_typing.Sequence[_typing.Sequence[int]], NOTSETTYPE, None]=NOTSET,
        fieldG: _typing.Union[_typing.Mapping[str, _typing.Mapping[str, _typing.Mapping[str, int]]], NOTSETTYPE, None]=NOTSET,
        fieldH: _typing.Union[_typing.Sequence[_typing.AbstractSet[int]], NOTSETTYPE, None]=NOTSET,
        fieldI: _typing.Union[bool, NOTSETTYPE, None]=NOTSET,
        fieldJ: _typing.Union[_typing.Mapping[str, _typing.Sequence[int]], NOTSETTYPE, None]=NOTSET,
        fieldK: _typing.Union[_typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]], NOTSETTYPE, None]=NOTSET,
        fieldL: _typing.Union[_typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]], NOTSETTYPE, None]=NOTSET,
        fieldM: _typing.Union[_typing.Mapping[_typing.AbstractSet[_typing.Sequence[int]], _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]], NOTSETTYPE, None]=NOTSET,
        fieldN: _typing.Union[int, NOTSETTYPE, None]=NOTSET,
        fieldO: _typing.Union[_typing.Sequence[_typing.Mapping['Empty', 'MyStruct']], NOTSETTYPE, None]=NOTSET,
        fieldP: _typing.Union[_typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Mapping['Empty', 'MyStruct']]]], NOTSETTYPE, None]=NOTSET,
        fieldQ: _typing.Union[MyEnumA, NOTSETTYPE, None]=NOTSET,
        fieldR: _typing.Union[MyEnumA, NOTSETTYPE, None]=NOTSET,
        req_fieldR: _typing.Union[MyEnumA, NOTSETTYPE, None]=NOTSET,
        opt_fieldR: _typing.Union[MyEnumA, NOTSETTYPE, None]=NOTSET,
        fieldS: _typing.Union[MyEnumA, NOTSETTYPE, None]=NOTSET,
        fieldT: _typing.Union[_typing.Sequence[MyEnumA], NOTSETTYPE, None]=NOTSET,
        fieldU: _typing.Union[_typing.Sequence[MyEnumA], NOTSETTYPE, None]=NOTSET,
        fieldV: _typing.Union['MyStruct', NOTSETTYPE, None]=NOTSET,
        req_fieldV: _typing.Union['MyStruct', NOTSETTYPE]=NOTSET,
        opt_fieldV: _typing.Union['MyStruct', NOTSETTYPE, None]=NOTSET,
        fieldW: _typing.Union[_typing.AbstractSet['MyStruct'], NOTSETTYPE, None]=NOTSET,
        fieldX: _typing.Union['ComplexUnion', NOTSETTYPE, None]=NOTSET,
        req_fieldX: _typing.Union['ComplexUnion', NOTSETTYPE]=NOTSET,
        opt_fieldX: _typing.Union['ComplexUnion', NOTSETTYPE, None]=NOTSET,
        fieldY: _typing.Union[_typing.Sequence['ComplexUnion'], NOTSETTYPE, None]=NOTSET,
        fieldZ: _typing.Union[_typing.AbstractSet['SimpleUnion'], NOTSETTYPE, None]=NOTSET,
        fieldAA: _typing.Union[_typing.Sequence[_typing.AbstractSet['SimpleUnion']], NOTSETTYPE, None]=NOTSET,
        fieldAB: _typing.Union[_typing.Mapping[float, int], NOTSETTYPE, None]=NOTSET,
        fieldAC: _typing.Union[MyEnumB, NOTSETTYPE, None]=NOTSET,
        fieldAD: _typing.Union[_includes_types.AnEnum, NOTSETTYPE, None]=NOTSET,
        fieldAE: _typing.Union[_typing.Mapping[str, int], NOTSETTYPE, None]=NOTSET,
        fieldSD: _typing.Union[str, NOTSETTYPE, None]=NOTSET
    ) -> containerStruct: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['containerStruct'], bytes]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'containerStruct') -> bool: ...
    def __gt__(self, other: 'containerStruct') -> bool: ...
    def __le__(self, other: 'containerStruct') -> bool: ...
    def __ge__(self, other: 'containerStruct') -> bool: ...

    @__property__
    def fieldA(self) -> bool: ...
    @__property__
    def req_fieldA(self) -> bool: ...
    @__property__
    def opt_fieldA(self) -> _typing.Optional[bool]: ...
    @__property__
    def fieldB(self) -> _typing.Mapping[str, bool]: ...
    @__property__
    def req_fieldB(self) -> _typing.Mapping[str, bool]: ...
    @__property__
    def opt_fieldB(self) -> _typing.Optional[_typing.Mapping[str, bool]]: ...
    @__property__
    def fieldC(self) -> _typing.AbstractSet[int]: ...
    @__property__
    def req_fieldC(self) -> _typing.AbstractSet[int]: ...
    @__property__
    def opt_fieldC(self) -> _typing.AbstractSet[int]: ...
    @__property__
    def fieldD(self) -> str: ...
    @__property__
    def fieldE(self) -> str: ...
    @__property__
    def req_fieldE(self) -> str: ...
    @__property__
    def opt_fieldE(self) -> str: ...
    @__property__
    def fieldF(self) -> _typing.Sequence[_typing.Sequence[int]]: ...
    @__property__
    def fieldG(self) -> _typing.Mapping[str, _typing.Mapping[str, _typing.Mapping[str, int]]]: ...
    @__property__
    def fieldH(self) -> _typing.Sequence[_typing.AbstractSet[int]]: ...
    @__property__
    def fieldI(self) -> bool: ...
    @__property__
    def fieldJ(self) -> _typing.Mapping[str, _typing.Sequence[int]]: ...
    @__property__
    def fieldK(self) -> _typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]]: ...
    @__property__
    def fieldL(self) -> _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]: ...
    @__property__
    def fieldM(self) -> _typing.Mapping[_typing.AbstractSet[_typing.Sequence[int]], _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]]: ...
    @__property__
    def fieldN(self) -> int: ...
    @__property__
    def fieldO(self) -> _typing.Sequence[_typing.Mapping['Empty', 'MyStruct']]: ...
    @__property__
    def fieldP(self) -> _typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Mapping['Empty', 'MyStruct']]]]: ...
    @__property__
    def fieldQ(self) -> MyEnumA: ...
    @__property__
    def fieldR(self) -> MyEnumA: ...
    @__property__
    def req_fieldR(self) -> MyEnumA: ...
    @__property__
    def opt_fieldR(self) -> MyEnumA: ...
    @__property__
    def fieldS(self) -> MyEnumA: ...
    @__property__
    def fieldT(self) -> _typing.Sequence[MyEnumA]: ...
    @__property__
    def fieldU(self) -> _typing.Sequence[MyEnumA]: ...
    @__property__
    def fieldV(self) -> 'MyStruct': ...
    @__property__
    def req_fieldV(self) -> 'MyStruct': ...
    @__property__
    def opt_fieldV(self) -> _typing.Optional['MyStruct']: ...
    @__property__
    def fieldW(self) -> _typing.AbstractSet['MyStruct']: ...
    @__property__
    def fieldX(self) -> 'ComplexUnion': ...
    @__property__
    def req_fieldX(self) -> 'ComplexUnion': ...
    @__property__
    def opt_fieldX(self) -> _typing.Optional['ComplexUnion']: ...
    @__property__
    def fieldY(self) -> _typing.Sequence['ComplexUnion']: ...
    @__property__
    def fieldZ(self) -> _typing.AbstractSet['SimpleUnion']: ...
    @__property__
    def fieldAA(self) -> _typing.Sequence[_typing.AbstractSet['SimpleUnion']]: ...
    @__property__
    def fieldAB(self) -> _typing.Mapping[float, int]: ...
    @__property__
    def fieldAC(self) -> MyEnumB: ...
    @__property__
    def fieldAD(self) -> _includes_types.AnEnum: ...
    @__property__
    def fieldAE(self) -> _typing.Mapping[str, int]: ...
    @__property__
    def fieldSD(self) -> str: ...


class MyIncludedStruct(thrift.py3.types.Struct, _typing.Hashable, _typing.Iterable[_typing.Tuple[str, _typing.Any]]):
    def __init__(
        self, *,
        MyIncludedInt: _typing.Optional[int]=None,
        MyIncludedStruct: _typing.Optional[_includes_types.AStruct]=None,
        ARefField: _typing.Optional[_includes_types.AStruct]=None,
        ARequiredField: _includes_types.AStruct
    ) -> None: ...

    def __call__(
        self, *,
        MyIncludedInt: _typing.Union[int, NOTSETTYPE, None]=NOTSET,
        MyIncludedStruct: _typing.Union[_includes_types.AStruct, NOTSETTYPE, None]=NOTSET,
        ARefField: _typing.Union[_includes_types.AStruct, NOTSETTYPE, None]=NOTSET,
        ARequiredField: _typing.Union[_includes_types.AStruct, NOTSETTYPE]=NOTSET
    ) -> MyIncludedStruct: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['MyIncludedStruct'], bytes]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'MyIncludedStruct') -> bool: ...
    def __gt__(self, other: 'MyIncludedStruct') -> bool: ...
    def __le__(self, other: 'MyIncludedStruct') -> bool: ...
    def __ge__(self, other: 'MyIncludedStruct') -> bool: ...

    @__property__
    def MyIncludedInt(self) -> int: ...
    @__property__
    def MyIncludedStruct(self) -> _includes_types.AStruct: ...
    @__property__
    def ARefField(self) -> _typing.Optional[_includes_types.AStruct]: ...
    @__property__
    def ARequiredField(self) -> _includes_types.AStruct: ...


class AnnotatedStruct(thrift.py3.types.Struct, _typing.Hashable, _typing.Iterable[_typing.Tuple[str, _typing.Any]]):
    def __init__(
        self, *,
        no_annotation: _typing.Optional['containerStruct']=None,
        cpp_unique_ref: _typing.Optional['containerStruct']=None,
        cpp2_unique_ref: _typing.Optional['containerStruct']=None,
        container_with_ref: _typing.Optional[_typing.Mapping[int, _typing.Sequence[str]]]=None,
        req_cpp_unique_ref: 'containerStruct',
        req_cpp2_unique_ref: 'containerStruct',
        req_container_with_ref: _typing.Sequence[str],
        opt_cpp_unique_ref: _typing.Optional['containerStruct']=None,
        opt_cpp2_unique_ref: _typing.Optional['containerStruct']=None,
        opt_container_with_ref: _typing.Optional[_typing.AbstractSet[int]]=None,
        ref_type_unique: _typing.Optional['containerStruct']=None,
        ref_type_shared: _typing.Optional['containerStruct']=None,
        ref_type_const: _typing.Optional[_typing.Mapping[int, _typing.Sequence[str]]]=None,
        req_ref_type_shared: 'containerStruct',
        req_ref_type_const: 'containerStruct',
        req_ref_type_unique: _typing.Sequence[str],
        opt_ref_type_const: _typing.Optional['containerStruct']=None,
        opt_ref_type_unique: _typing.Optional['containerStruct']=None,
        opt_ref_type_shared: _typing.Optional[_typing.AbstractSet[int]]=None,
        base_type: _typing.Optional[int]=None,
        list_type: _typing.Optional[_typing.Sequence[int]]=None,
        set_type: _typing.Optional[_typing.AbstractSet[str]]=None,
        map_type: _typing.Optional[_typing.Mapping[int, float]]=None,
        map_struct_type: _typing.Optional[_typing.Mapping[str, 'containerStruct']]=None,
        iobuf_type: _typing.Optional[__iobuf.IOBuf]=None,
        iobuf_ptr: _typing.Optional[__iobuf.IOBuf]=None,
        list_i32_template: _typing.Optional[_typing.Sequence[int]]=None,
        list_string_template: _typing.Optional[_typing.Sequence[str]]=None,
        set_template: _typing.Optional[_typing.AbstractSet[str]]=None,
        map_template: _typing.Optional[_typing.Mapping[int, str]]=None,
        typedef_list_template: _typing.Optional[_typing.Sequence[int]]=None,
        typedef_deque_template: _typing.Optional[_typing.Sequence[str]]=None,
        typedef_set_template: _typing.Optional[_typing.AbstractSet[str]]=None,
        typedef_map_template: _typing.Optional[_typing.Mapping[int, str]]=None,
        indirection_a: _typing.Optional[int]=None,
        indirection_b: _typing.Optional[_typing.Sequence[float]]=None,
        indirection_c: _typing.Optional[_typing.AbstractSet[int]]=None,
        iobuf_type_val: _typing.Optional[__iobuf.IOBuf]=None,
        iobuf_ptr_val: _typing.Optional[__iobuf.IOBuf]=None,
        struct_struct: _typing.Optional['containerStruct']=None
    ) -> None: ...

    def __call__(
        self, *,
        no_annotation: _typing.Union['containerStruct', NOTSETTYPE, None]=NOTSET,
        cpp_unique_ref: _typing.Union['containerStruct', NOTSETTYPE, None]=NOTSET,
        cpp2_unique_ref: _typing.Union['containerStruct', NOTSETTYPE, None]=NOTSET,
        container_with_ref: _typing.Union[_typing.Mapping[int, _typing.Sequence[str]], NOTSETTYPE, None]=NOTSET,
        req_cpp_unique_ref: _typing.Union['containerStruct', NOTSETTYPE]=NOTSET,
        req_cpp2_unique_ref: _typing.Union['containerStruct', NOTSETTYPE]=NOTSET,
        req_container_with_ref: _typing.Union[_typing.Sequence[str], NOTSETTYPE]=NOTSET,
        opt_cpp_unique_ref: _typing.Union['containerStruct', NOTSETTYPE, None]=NOTSET,
        opt_cpp2_unique_ref: _typing.Union['containerStruct', NOTSETTYPE, None]=NOTSET,
        opt_container_with_ref: _typing.Union[_typing.AbstractSet[int], NOTSETTYPE, None]=NOTSET,
        ref_type_unique: _typing.Union['containerStruct', NOTSETTYPE, None]=NOTSET,
        ref_type_shared: _typing.Union['containerStruct', NOTSETTYPE, None]=NOTSET,
        ref_type_const: _typing.Union[_typing.Mapping[int, _typing.Sequence[str]], NOTSETTYPE, None]=NOTSET,
        req_ref_type_shared: _typing.Union['containerStruct', NOTSETTYPE]=NOTSET,
        req_ref_type_const: _typing.Union['containerStruct', NOTSETTYPE]=NOTSET,
        req_ref_type_unique: _typing.Union[_typing.Sequence[str], NOTSETTYPE]=NOTSET,
        opt_ref_type_const: _typing.Union['containerStruct', NOTSETTYPE, None]=NOTSET,
        opt_ref_type_unique: _typing.Union['containerStruct', NOTSETTYPE, None]=NOTSET,
        opt_ref_type_shared: _typing.Union[_typing.AbstractSet[int], NOTSETTYPE, None]=NOTSET,
        base_type: _typing.Union[int, NOTSETTYPE, None]=NOTSET,
        list_type: _typing.Union[_typing.Sequence[int], NOTSETTYPE, None]=NOTSET,
        set_type: _typing.Union[_typing.AbstractSet[str], NOTSETTYPE, None]=NOTSET,
        map_type: _typing.Union[_typing.Mapping[int, float], NOTSETTYPE, None]=NOTSET,
        map_struct_type: _typing.Union[_typing.Mapping[str, 'containerStruct'], NOTSETTYPE, None]=NOTSET,
        iobuf_type: _typing.Union[__iobuf.IOBuf, NOTSETTYPE, None]=NOTSET,
        iobuf_ptr: _typing.Union[__iobuf.IOBuf, NOTSETTYPE, None]=NOTSET,
        list_i32_template: _typing.Union[_typing.Sequence[int], NOTSETTYPE, None]=NOTSET,
        list_string_template: _typing.Union[_typing.Sequence[str], NOTSETTYPE, None]=NOTSET,
        set_template: _typing.Union[_typing.AbstractSet[str], NOTSETTYPE, None]=NOTSET,
        map_template: _typing.Union[_typing.Mapping[int, str], NOTSETTYPE, None]=NOTSET,
        typedef_list_template: _typing.Union[_typing.Sequence[int], NOTSETTYPE, None]=NOTSET,
        typedef_deque_template: _typing.Union[_typing.Sequence[str], NOTSETTYPE, None]=NOTSET,
        typedef_set_template: _typing.Union[_typing.AbstractSet[str], NOTSETTYPE, None]=NOTSET,
        typedef_map_template: _typing.Union[_typing.Mapping[int, str], NOTSETTYPE, None]=NOTSET,
        indirection_a: _typing.Union[int, NOTSETTYPE, None]=NOTSET,
        indirection_b: _typing.Union[_typing.Sequence[float], NOTSETTYPE, None]=NOTSET,
        indirection_c: _typing.Union[_typing.AbstractSet[int], NOTSETTYPE, None]=NOTSET,
        iobuf_type_val: _typing.Union[__iobuf.IOBuf, NOTSETTYPE, None]=NOTSET,
        iobuf_ptr_val: _typing.Union[__iobuf.IOBuf, NOTSETTYPE, None]=NOTSET,
        struct_struct: _typing.Union['containerStruct', NOTSETTYPE, None]=NOTSET
    ) -> AnnotatedStruct: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['AnnotatedStruct'], bytes]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...

    @__property__
    def no_annotation(self) -> 'containerStruct': ...
    @__property__
    def cpp_unique_ref(self) -> _typing.Optional['containerStruct']: ...
    @__property__
    def cpp2_unique_ref(self) -> _typing.Optional['containerStruct']: ...
    @__property__
    def container_with_ref(self) -> _typing.Optional[_typing.Mapping[int, _typing.Sequence[str]]]: ...
    @__property__
    def req_cpp_unique_ref(self) -> 'containerStruct': ...
    @__property__
    def req_cpp2_unique_ref(self) -> 'containerStruct': ...
    @__property__
    def req_container_with_ref(self) -> _typing.Sequence[str]: ...
    @__property__
    def opt_cpp_unique_ref(self) -> _typing.Optional['containerStruct']: ...
    @__property__
    def opt_cpp2_unique_ref(self) -> _typing.Optional['containerStruct']: ...
    @__property__
    def opt_container_with_ref(self) -> _typing.Optional[_typing.AbstractSet[int]]: ...
    @__property__
    def ref_type_unique(self) -> _typing.Optional['containerStruct']: ...
    @__property__
    def ref_type_shared(self) -> _typing.Optional['containerStruct']: ...
    @__property__
    def ref_type_const(self) -> _typing.Optional[_typing.Mapping[int, _typing.Sequence[str]]]: ...
    @__property__
    def req_ref_type_shared(self) -> 'containerStruct': ...
    @__property__
    def req_ref_type_const(self) -> 'containerStruct': ...
    @__property__
    def req_ref_type_unique(self) -> _typing.Sequence[str]: ...
    @__property__
    def opt_ref_type_const(self) -> _typing.Optional['containerStruct']: ...
    @__property__
    def opt_ref_type_unique(self) -> _typing.Optional['containerStruct']: ...
    @__property__
    def opt_ref_type_shared(self) -> _typing.Optional[_typing.AbstractSet[int]]: ...
    @__property__
    def base_type(self) -> int: ...
    @__property__
    def list_type(self) -> _typing.Sequence[int]: ...
    @__property__
    def set_type(self) -> _typing.AbstractSet[str]: ...
    @__property__
    def map_type(self) -> _typing.Mapping[int, float]: ...
    @__property__
    def map_struct_type(self) -> _typing.Mapping[str, 'containerStruct']: ...
    @__property__
    def iobuf_type(self) -> __iobuf.IOBuf: ...
    @__property__
    def iobuf_ptr(self) -> _typing.Optional[__iobuf.IOBuf]: ...
    @__property__
    def list_i32_template(self) -> _typing.Sequence[int]: ...
    @__property__
    def list_string_template(self) -> _typing.Sequence[str]: ...
    @__property__
    def set_template(self) -> _typing.AbstractSet[str]: ...
    @__property__
    def map_template(self) -> _typing.Mapping[int, str]: ...
    @__property__
    def typedef_list_template(self) -> _typing.Sequence[int]: ...
    @__property__
    def typedef_deque_template(self) -> _typing.Sequence[str]: ...
    @__property__
    def typedef_set_template(self) -> _typing.AbstractSet[str]: ...
    @__property__
    def typedef_map_template(self) -> _typing.Mapping[int, str]: ...
    @__property__
    def indirection_a(self) -> int: ...
    @__property__
    def indirection_b(self) -> _typing.Sequence[float]: ...
    @__property__
    def indirection_c(self) -> _typing.AbstractSet[int]: ...
    @__property__
    def iobuf_type_val(self) -> __iobuf.IOBuf: ...
    @__property__
    def iobuf_ptr_val(self) -> _typing.Optional[__iobuf.IOBuf]: ...
    @__property__
    def struct_struct(self) -> 'containerStruct': ...


class ComplexContainerStruct(thrift.py3.types.Struct, _typing.Hashable, _typing.Iterable[_typing.Tuple[str, _typing.Any]]):
    def __init__(
        self, *,
        map_of_iobufs: _typing.Optional[_typing.Mapping[str, __iobuf.IOBuf]]=None,
        map_of_iobuf_ptrs: _typing.Optional[_typing.Mapping[str, __iobuf.IOBuf]]=None
    ) -> None: ...

    def __call__(
        self, *,
        map_of_iobufs: _typing.Union[_typing.Mapping[str, __iobuf.IOBuf], NOTSETTYPE, None]=NOTSET,
        map_of_iobuf_ptrs: _typing.Union[_typing.Mapping[str, __iobuf.IOBuf], NOTSETTYPE, None]=NOTSET
    ) -> ComplexContainerStruct: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['ComplexContainerStruct'], bytes]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'ComplexContainerStruct') -> bool: ...
    def __gt__(self, other: 'ComplexContainerStruct') -> bool: ...
    def __le__(self, other: 'ComplexContainerStruct') -> bool: ...
    def __ge__(self, other: 'ComplexContainerStruct') -> bool: ...

    @__property__
    def map_of_iobufs(self) -> _typing.Mapping[str, __iobuf.IOBuf]: ...
    @__property__
    def map_of_iobuf_ptrs(self) -> _typing.Mapping[str, __iobuf.IOBuf]: ...


class FloatStruct(thrift.py3.types.Struct, _typing.Hashable, _typing.Iterable[_typing.Tuple[str, _typing.Any]]):
    def __init__(
        self, *,
        floatField: _typing.Optional[float]=None,
        doubleField: _typing.Optional[float]=None
    ) -> None: ...

    def __call__(
        self, *,
        floatField: _typing.Union[float, NOTSETTYPE, None]=NOTSET,
        doubleField: _typing.Union[float, NOTSETTYPE, None]=NOTSET
    ) -> FloatStruct: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['FloatStruct'], bytes]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'FloatStruct') -> bool: ...
    def __gt__(self, other: 'FloatStruct') -> bool: ...
    def __le__(self, other: 'FloatStruct') -> bool: ...
    def __ge__(self, other: 'FloatStruct') -> bool: ...

    @__property__
    def floatField(self) -> float: ...
    @__property__
    def doubleField(self) -> float: ...


class FloatUnion(thrift.py3.types.Union, _typing.Hashable):
    def __init__(
        self, *,
        floatSide: _typing.Optional[float]=None,
        doubleSide: _typing.Optional[float]=None
    ) -> None: ...

    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'FloatUnion') -> bool: ...
    def __gt__(self, other: 'FloatUnion') -> bool: ...
    def __le__(self, other: 'FloatUnion') -> bool: ...
    def __ge__(self, other: 'FloatUnion') -> bool: ...

    @__property__
    def floatSide(self) -> float: ...
    @__property__
    def doubleSide(self) -> float: ...
    class Type(thrift.py3.types.Enum):
        EMPTY: FloatUnion.Type = ...
        floatSide: FloatUnion.Type = ...
        doubleSide: FloatUnion.Type = ...

    @staticmethod
    def fromValue(value: _typing.Union[None, float, float]) -> FloatUnion: ...
    @__property__
    def value(self) -> _typing.Union[None, float, float]: ...
    @__property__
    def type(self) -> "FloatUnion.Type": ...
    def get_type(self) -> "FloatUnion.Type": ...


class AllRequiredNoExceptMoveCtrStruct(thrift.py3.types.Struct, _typing.Hashable, _typing.Iterable[_typing.Tuple[str, _typing.Any]]):
    def __init__(
        self, *,
        intField: int
    ) -> None: ...

    def __call__(
        self, *,
        intField: _typing.Union[int, NOTSETTYPE]=NOTSET
    ) -> AllRequiredNoExceptMoveCtrStruct: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['AllRequiredNoExceptMoveCtrStruct'], bytes]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'AllRequiredNoExceptMoveCtrStruct') -> bool: ...
    def __gt__(self, other: 'AllRequiredNoExceptMoveCtrStruct') -> bool: ...
    def __le__(self, other: 'AllRequiredNoExceptMoveCtrStruct') -> bool: ...
    def __ge__(self, other: 'AllRequiredNoExceptMoveCtrStruct') -> bool: ...

    @__property__
    def intField(self) -> int: ...


class Map__string_i64(_typing.Mapping[str, int], _typing.Hashable):
    def __init__(self, items: _typing.Mapping[str, int]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Mapping[str, int]: ...
    def __getitem__(self, key: str) -> int: ...
    def __iter__(self) -> _typing.Iterator[str]: ...


class Map__Empty_MyStruct(_typing.Mapping['Empty', 'MyStruct'], _typing.Hashable):
    def __init__(self, items: _typing.Mapping['Empty', 'MyStruct']=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Mapping['Empty', 'MyStruct']: ...
    def __getitem__(self, key: 'Empty') -> 'MyStruct': ...
    def __iter__(self) -> _typing.Iterator['Empty']: ...


_List__Map__Empty_MyStructT = _typing.TypeVar('_List__Map__Empty_MyStructT', bound=_typing.Sequence[_typing.Mapping['Empty', 'MyStruct']])


class List__Map__Empty_MyStruct(_typing.Sequence[_typing.Mapping['Empty', 'MyStruct']], _typing.Hashable):
    def __init__(self, items: _typing.Sequence[_typing.Mapping['Empty', 'MyStruct']]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Sequence[_typing.Mapping['Empty', 'MyStruct']]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> _typing.Mapping['Empty', 'MyStruct']: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[_typing.Mapping['Empty', 'MyStruct']]: ...
    def count(self, item: _typing.Any) -> int: ...
    def index(self, item: _typing.Any, start: int = ..., stop: int = ...) -> int: ...
    def __add__(self, other: _typing.Sequence[_typing.Mapping['Empty', 'MyStruct']]) -> 'List__Map__Empty_MyStruct': ...
    def __radd__(self, other: _List__Map__Empty_MyStructT) -> _List__Map__Empty_MyStructT: ...
    def __reversed__(self) -> _typing.Iterator[_typing.Mapping['Empty', 'MyStruct']]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Mapping['Empty', 'MyStruct']]: ...


_List__List__Map__Empty_MyStructT = _typing.TypeVar('_List__List__Map__Empty_MyStructT', bound=_typing.Sequence[_typing.Sequence[_typing.Mapping['Empty', 'MyStruct']]])


class List__List__Map__Empty_MyStruct(_typing.Sequence[_typing.Sequence[_typing.Mapping['Empty', 'MyStruct']]], _typing.Hashable):
    def __init__(self, items: _typing.Sequence[_typing.Sequence[_typing.Mapping['Empty', 'MyStruct']]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Sequence[_typing.Sequence[_typing.Mapping['Empty', 'MyStruct']]]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> _typing.Sequence[_typing.Mapping['Empty', 'MyStruct']]: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[_typing.Sequence[_typing.Mapping['Empty', 'MyStruct']]]: ...
    def count(self, item: _typing.Any) -> int: ...
    def index(self, item: _typing.Any, start: int = ..., stop: int = ...) -> int: ...
    def __add__(self, other: _typing.Sequence[_typing.Sequence[_typing.Mapping['Empty', 'MyStruct']]]) -> 'List__List__Map__Empty_MyStruct': ...
    def __radd__(self, other: _List__List__Map__Empty_MyStructT) -> _List__List__Map__Empty_MyStructT: ...
    def __reversed__(self) -> _typing.Iterator[_typing.Sequence[_typing.Mapping['Empty', 'MyStruct']]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Sequence[_typing.Mapping['Empty', 'MyStruct']]]: ...


_List__List__List__Map__Empty_MyStructT = _typing.TypeVar('_List__List__List__Map__Empty_MyStructT', bound=_typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Mapping['Empty', 'MyStruct']]]])


class List__List__List__Map__Empty_MyStruct(_typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Mapping['Empty', 'MyStruct']]]], _typing.Hashable):
    def __init__(self, items: _typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Mapping['Empty', 'MyStruct']]]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Mapping['Empty', 'MyStruct']]]]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> _typing.Sequence[_typing.Sequence[_typing.Mapping['Empty', 'MyStruct']]]: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Mapping['Empty', 'MyStruct']]]]: ...
    def count(self, item: _typing.Any) -> int: ...
    def index(self, item: _typing.Any, start: int = ..., stop: int = ...) -> int: ...
    def __add__(self, other: _typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Mapping['Empty', 'MyStruct']]]]) -> 'List__List__List__Map__Empty_MyStruct': ...
    def __radd__(self, other: _List__List__List__Map__Empty_MyStructT) -> _List__List__List__Map__Empty_MyStructT: ...
    def __reversed__(self) -> _typing.Iterator[_typing.Sequence[_typing.Sequence[_typing.Mapping['Empty', 'MyStruct']]]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Sequence[_typing.Sequence[_typing.Mapping['Empty', 'MyStruct']]]]: ...


_List__MyEnumAT = _typing.TypeVar('_List__MyEnumAT', bound=_typing.Sequence[MyEnumA])


class List__MyEnumA(_typing.Sequence[MyEnumA], _typing.Hashable):
    def __init__(self, items: _typing.Sequence[MyEnumA]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Sequence[MyEnumA]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> MyEnumA: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[MyEnumA]: ...
    def count(self, item: _typing.Any) -> int: ...
    def index(self, item: _typing.Any, start: int = ..., stop: int = ...) -> int: ...
    def __add__(self, other: _typing.Sequence[MyEnumA]) -> 'List__MyEnumA': ...
    def __radd__(self, other: _List__MyEnumAT) -> _List__MyEnumAT: ...
    def __reversed__(self) -> _typing.Iterator[MyEnumA]: ...
    def __iter__(self) -> _typing.Iterator[MyEnumA]: ...


class Set__MyStruct(_typing.AbstractSet['MyStruct'], _typing.Hashable):
    def __init__(self, items: _typing.AbstractSet['MyStruct']=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.AbstractSet['MyStruct']: ...
    def isdisjoint(self, other: _typing.AbstractSet['MyStruct']) -> bool: ...
    def union(self, other: _typing.AbstractSet['MyStruct']) -> 'Set__MyStruct': ...
    def intersection(self, other: _typing.AbstractSet['MyStruct']) -> 'Set__MyStruct': ...
    def difference(self, other: _typing.AbstractSet['MyStruct']) -> 'Set__MyStruct': ...
    def symmetric_difference(self, other: _typing.AbstractSet['MyStruct']) -> 'Set__MyStruct': ...
    def issubset(self, other: _typing.AbstractSet['MyStruct']) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet['MyStruct']) -> bool: ...
    def __iter__(self) -> _typing.Iterator['MyStruct']: ...


_List__ComplexUnionT = _typing.TypeVar('_List__ComplexUnionT', bound=_typing.Sequence['ComplexUnion'])


class List__ComplexUnion(_typing.Sequence['ComplexUnion'], _typing.Hashable):
    def __init__(self, items: _typing.Sequence['ComplexUnion']=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Sequence['ComplexUnion']: ...
    @_typing.overload
    def __getitem__(self, i: int) -> 'ComplexUnion': ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence['ComplexUnion']: ...
    def count(self, item: _typing.Any) -> int: ...
    def index(self, item: _typing.Any, start: int = ..., stop: int = ...) -> int: ...
    def __add__(self, other: _typing.Sequence['ComplexUnion']) -> 'List__ComplexUnion': ...
    def __radd__(self, other: _List__ComplexUnionT) -> _List__ComplexUnionT: ...
    def __reversed__(self) -> _typing.Iterator['ComplexUnion']: ...
    def __iter__(self) -> _typing.Iterator['ComplexUnion']: ...


_List__stringT = _typing.TypeVar('_List__stringT', bound=_typing.Sequence[str])


class List__string(_typing.Sequence[str], _typing.Hashable):
    def __init__(self, items: _typing.Sequence[str]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Sequence[str]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> str: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[str]: ...
    def count(self, item: _typing.Any) -> int: ...
    def index(self, item: _typing.Any, start: int = ..., stop: int = ...) -> int: ...
    def __add__(self, other: _typing.Sequence[str]) -> 'List__string': ...
    def __radd__(self, other: _List__stringT) -> _List__stringT: ...
    def __reversed__(self) -> _typing.Iterator[str]: ...
    def __iter__(self) -> _typing.Iterator[str]: ...


class Set__List__string(_typing.AbstractSet[_typing.Sequence[str]], _typing.Hashable):
    def __init__(self, items: _typing.AbstractSet[_typing.Sequence[str]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.AbstractSet[_typing.Sequence[str]]: ...
    def isdisjoint(self, other: _typing.AbstractSet[_typing.Sequence[str]]) -> bool: ...
    def union(self, other: _typing.AbstractSet[_typing.Sequence[str]]) -> 'Set__List__string': ...
    def intersection(self, other: _typing.AbstractSet[_typing.Sequence[str]]) -> 'Set__List__string': ...
    def difference(self, other: _typing.AbstractSet[_typing.Sequence[str]]) -> 'Set__List__string': ...
    def symmetric_difference(self, other: _typing.AbstractSet[_typing.Sequence[str]]) -> 'Set__List__string': ...
    def issubset(self, other: _typing.AbstractSet[_typing.Sequence[str]]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[_typing.Sequence[str]]) -> bool: ...
    def __iter__(self) -> _typing.Iterator[_typing.Sequence[str]]: ...


class Set__List__List__Map__Empty_MyStruct(_typing.AbstractSet[_typing.Sequence[_typing.Sequence[_typing.Mapping['Empty', 'MyStruct']]]], _typing.Hashable):
    def __init__(self, items: _typing.AbstractSet[_typing.Sequence[_typing.Sequence[_typing.Mapping['Empty', 'MyStruct']]]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.AbstractSet[_typing.Sequence[_typing.Sequence[_typing.Mapping['Empty', 'MyStruct']]]]: ...
    def isdisjoint(self, other: _typing.AbstractSet[_typing.Sequence[_typing.Sequence[_typing.Mapping['Empty', 'MyStruct']]]]) -> bool: ...
    def union(self, other: _typing.AbstractSet[_typing.Sequence[_typing.Sequence[_typing.Mapping['Empty', 'MyStruct']]]]) -> 'Set__List__List__Map__Empty_MyStruct': ...
    def intersection(self, other: _typing.AbstractSet[_typing.Sequence[_typing.Sequence[_typing.Mapping['Empty', 'MyStruct']]]]) -> 'Set__List__List__Map__Empty_MyStruct': ...
    def difference(self, other: _typing.AbstractSet[_typing.Sequence[_typing.Sequence[_typing.Mapping['Empty', 'MyStruct']]]]) -> 'Set__List__List__Map__Empty_MyStruct': ...
    def symmetric_difference(self, other: _typing.AbstractSet[_typing.Sequence[_typing.Sequence[_typing.Mapping['Empty', 'MyStruct']]]]) -> 'Set__List__List__Map__Empty_MyStruct': ...
    def issubset(self, other: _typing.AbstractSet[_typing.Sequence[_typing.Sequence[_typing.Mapping['Empty', 'MyStruct']]]]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[_typing.Sequence[_typing.Sequence[_typing.Mapping['Empty', 'MyStruct']]]]) -> bool: ...
    def __iter__(self) -> _typing.Iterator[_typing.Sequence[_typing.Sequence[_typing.Mapping['Empty', 'MyStruct']]]]: ...


class Map__i32_List__string(_typing.Mapping[int, _typing.Sequence[str]], _typing.Hashable):
    def __init__(self, items: _typing.Mapping[int, _typing.Sequence[str]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Mapping[int, _typing.Sequence[str]]: ...
    def __getitem__(self, key: int) -> _typing.Sequence[str]: ...
    def __iter__(self) -> _typing.Iterator[int]: ...


_List__boolT = _typing.TypeVar('_List__boolT', bound=_typing.Sequence[bool])


class List__bool(_typing.Sequence[bool], _typing.Hashable):
    def __init__(self, items: _typing.Sequence[bool]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Sequence[bool]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> bool: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[bool]: ...
    def count(self, item: _typing.Any) -> int: ...
    def index(self, item: _typing.Any, start: int = ..., stop: int = ...) -> int: ...
    def __add__(self, other: _typing.Sequence[bool]) -> 'List__bool': ...
    def __radd__(self, other: _List__boolT) -> _List__boolT: ...
    def __reversed__(self) -> _typing.Iterator[bool]: ...
    def __iter__(self) -> _typing.Iterator[bool]: ...


_List__i32T = _typing.TypeVar('_List__i32T', bound=_typing.Sequence[int])


class List__i32(_typing.Sequence[int], _typing.Hashable):
    def __init__(self, items: _typing.Sequence[int]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Sequence[int]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> int: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[int]: ...
    def count(self, item: _typing.Any) -> int: ...
    def index(self, item: _typing.Any, start: int = ..., stop: int = ...) -> int: ...
    def __add__(self, other: _typing.Sequence[int]) -> 'List__i32': ...
    def __radd__(self, other: _List__i32T) -> _List__i32T: ...
    def __reversed__(self) -> _typing.Iterator[int]: ...
    def __iter__(self) -> _typing.Iterator[int]: ...


_List__List__i32T = _typing.TypeVar('_List__List__i32T', bound=_typing.Sequence[_typing.Sequence[int]])


class List__List__i32(_typing.Sequence[_typing.Sequence[int]], _typing.Hashable):
    def __init__(self, items: _typing.Sequence[_typing.Sequence[int]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Sequence[_typing.Sequence[int]]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> _typing.Sequence[int]: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[_typing.Sequence[int]]: ...
    def count(self, item: _typing.Any) -> int: ...
    def index(self, item: _typing.Any, start: int = ..., stop: int = ...) -> int: ...
    def __add__(self, other: _typing.Sequence[_typing.Sequence[int]]) -> 'List__List__i32': ...
    def __radd__(self, other: _List__List__i32T) -> _List__List__i32T: ...
    def __reversed__(self) -> _typing.Iterator[_typing.Sequence[int]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Sequence[int]]: ...


_List__List__List__i32T = _typing.TypeVar('_List__List__List__i32T', bound=_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]])


class List__List__List__i32(_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]], _typing.Hashable):
    def __init__(self, items: _typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> _typing.Sequence[_typing.Sequence[int]]: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]: ...
    def count(self, item: _typing.Any) -> int: ...
    def index(self, item: _typing.Any, start: int = ..., stop: int = ...) -> int: ...
    def __add__(self, other: _typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]) -> 'List__List__List__i32': ...
    def __radd__(self, other: _List__List__List__i32T) -> _List__List__List__i32T: ...
    def __reversed__(self) -> _typing.Iterator[_typing.Sequence[_typing.Sequence[int]]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Sequence[_typing.Sequence[int]]]: ...


_List__List__List__List__i32T = _typing.TypeVar('_List__List__List__List__i32T', bound=_typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]])


class List__List__List__List__i32(_typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]], _typing.Hashable):
    def __init__(self, items: _typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> _typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]]: ...
    def count(self, item: _typing.Any) -> int: ...
    def index(self, item: _typing.Any, start: int = ..., stop: int = ...) -> int: ...
    def __add__(self, other: _typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]]) -> 'List__List__List__List__i32': ...
    def __radd__(self, other: _List__List__List__List__i32T) -> _List__List__List__List__i32T: ...
    def __reversed__(self) -> _typing.Iterator[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]]: ...


class Set__List__i32(_typing.AbstractSet[_typing.Sequence[int]], _typing.Hashable):
    def __init__(self, items: _typing.AbstractSet[_typing.Sequence[int]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.AbstractSet[_typing.Sequence[int]]: ...
    def isdisjoint(self, other: _typing.AbstractSet[_typing.Sequence[int]]) -> bool: ...
    def union(self, other: _typing.AbstractSet[_typing.Sequence[int]]) -> 'Set__List__i32': ...
    def intersection(self, other: _typing.AbstractSet[_typing.Sequence[int]]) -> 'Set__List__i32': ...
    def difference(self, other: _typing.AbstractSet[_typing.Sequence[int]]) -> 'Set__List__i32': ...
    def symmetric_difference(self, other: _typing.AbstractSet[_typing.Sequence[int]]) -> 'Set__List__i32': ...
    def issubset(self, other: _typing.AbstractSet[_typing.Sequence[int]]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[_typing.Sequence[int]]) -> bool: ...
    def __iter__(self) -> _typing.Iterator[_typing.Sequence[int]]: ...


class Set__string(_typing.AbstractSet[str], _typing.Hashable):
    def __init__(self, items: _typing.AbstractSet[str]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.AbstractSet[str]: ...
    def isdisjoint(self, other: _typing.AbstractSet[str]) -> bool: ...
    def union(self, other: _typing.AbstractSet[str]) -> 'Set__string': ...
    def intersection(self, other: _typing.AbstractSet[str]) -> 'Set__string': ...
    def difference(self, other: _typing.AbstractSet[str]) -> 'Set__string': ...
    def symmetric_difference(self, other: _typing.AbstractSet[str]) -> 'Set__string': ...
    def issubset(self, other: _typing.AbstractSet[str]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[str]) -> bool: ...
    def __iter__(self) -> _typing.Iterator[str]: ...


_List__Set__stringT = _typing.TypeVar('_List__Set__stringT', bound=_typing.Sequence[_typing.AbstractSet[str]])


class List__Set__string(_typing.Sequence[_typing.AbstractSet[str]], _typing.Hashable):
    def __init__(self, items: _typing.Sequence[_typing.AbstractSet[str]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Sequence[_typing.AbstractSet[str]]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> _typing.AbstractSet[str]: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[_typing.AbstractSet[str]]: ...
    def count(self, item: _typing.Any) -> int: ...
    def index(self, item: _typing.Any, start: int = ..., stop: int = ...) -> int: ...
    def __add__(self, other: _typing.Sequence[_typing.AbstractSet[str]]) -> 'List__Set__string': ...
    def __radd__(self, other: _List__Set__stringT) -> _List__Set__stringT: ...
    def __reversed__(self) -> _typing.Iterator[_typing.AbstractSet[str]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.AbstractSet[str]]: ...


class Map__List__Set__string_string(_typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str], _typing.Hashable):
    def __init__(self, items: _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]: ...
    def __getitem__(self, key: _typing.Sequence[_typing.AbstractSet[str]]) -> str: ...
    def __iter__(self) -> _typing.Iterator[_typing.Sequence[_typing.AbstractSet[str]]]: ...


class Map__Set__List__i32_Map__List__Set__string_string(_typing.Mapping[_typing.AbstractSet[_typing.Sequence[int]], _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]], _typing.Hashable):
    def __init__(self, items: _typing.Mapping[_typing.AbstractSet[_typing.Sequence[int]], _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Mapping[_typing.AbstractSet[_typing.Sequence[int]], _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]]: ...
    def __getitem__(self, key: _typing.AbstractSet[_typing.Sequence[int]]) -> _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]: ...
    def __iter__(self) -> _typing.Iterator[_typing.AbstractSet[_typing.Sequence[int]]]: ...


_List__binaryT = _typing.TypeVar('_List__binaryT', bound=_typing.Sequence[bytes])


class List__binary(_typing.Sequence[bytes], _typing.Hashable):
    def __init__(self, items: _typing.Sequence[bytes]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Sequence[bytes]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> bytes: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[bytes]: ...
    def count(self, item: _typing.Any) -> int: ...
    def index(self, item: _typing.Any, start: int = ..., stop: int = ...) -> int: ...
    def __add__(self, other: _typing.Sequence[bytes]) -> 'List__binary': ...
    def __radd__(self, other: _List__binaryT) -> _List__binaryT: ...
    def __reversed__(self) -> _typing.Iterator[bytes]: ...
    def __iter__(self) -> _typing.Iterator[bytes]: ...


class Map__MyEnumA_string(_typing.Mapping[MyEnumA, str], _typing.Hashable):
    def __init__(self, items: _typing.Mapping[MyEnumA, str]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Mapping[MyEnumA, str]: ...
    def __getitem__(self, key: MyEnumA) -> str: ...
    def __iter__(self) -> _typing.Iterator[MyEnumA]: ...


class Set__i64(_typing.AbstractSet[int], _typing.Hashable):
    def __init__(self, items: _typing.AbstractSet[int]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.AbstractSet[int]: ...
    def isdisjoint(self, other: _typing.AbstractSet[int]) -> bool: ...
    def union(self, other: _typing.AbstractSet[int]) -> 'Set__i64': ...
    def intersection(self, other: _typing.AbstractSet[int]) -> 'Set__i64': ...
    def difference(self, other: _typing.AbstractSet[int]) -> 'Set__i64': ...
    def symmetric_difference(self, other: _typing.AbstractSet[int]) -> 'Set__i64': ...
    def issubset(self, other: _typing.AbstractSet[int]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[int]) -> bool: ...
    def __iter__(self) -> _typing.Iterator[int]: ...


class Map__string_i32(_typing.Mapping[str, int], _typing.Hashable):
    def __init__(self, items: _typing.Mapping[str, int]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Mapping[str, int]: ...
    def __getitem__(self, key: str) -> int: ...
    def __iter__(self) -> _typing.Iterator[str]: ...


_List__SimpleUnionT = _typing.TypeVar('_List__SimpleUnionT', bound=_typing.Sequence['SimpleUnion'])


class List__SimpleUnion(_typing.Sequence['SimpleUnion'], _typing.Hashable):
    def __init__(self, items: _typing.Sequence['SimpleUnion']=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Sequence['SimpleUnion']: ...
    @_typing.overload
    def __getitem__(self, i: int) -> 'SimpleUnion': ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence['SimpleUnion']: ...
    def count(self, item: _typing.Any) -> int: ...
    def index(self, item: _typing.Any, start: int = ..., stop: int = ...) -> int: ...
    def __add__(self, other: _typing.Sequence['SimpleUnion']) -> 'List__SimpleUnion': ...
    def __radd__(self, other: _List__SimpleUnionT) -> _List__SimpleUnionT: ...
    def __reversed__(self) -> _typing.Iterator['SimpleUnion']: ...
    def __iter__(self) -> _typing.Iterator['SimpleUnion']: ...


class Set__SimpleUnion(_typing.AbstractSet['SimpleUnion'], _typing.Hashable):
    def __init__(self, items: _typing.AbstractSet['SimpleUnion']=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.AbstractSet['SimpleUnion']: ...
    def isdisjoint(self, other: _typing.AbstractSet['SimpleUnion']) -> bool: ...
    def union(self, other: _typing.AbstractSet['SimpleUnion']) -> 'Set__SimpleUnion': ...
    def intersection(self, other: _typing.AbstractSet['SimpleUnion']) -> 'Set__SimpleUnion': ...
    def difference(self, other: _typing.AbstractSet['SimpleUnion']) -> 'Set__SimpleUnion': ...
    def symmetric_difference(self, other: _typing.AbstractSet['SimpleUnion']) -> 'Set__SimpleUnion': ...
    def issubset(self, other: _typing.AbstractSet['SimpleUnion']) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet['SimpleUnion']) -> bool: ...
    def __iter__(self) -> _typing.Iterator['SimpleUnion']: ...


_List__Set__SimpleUnionT = _typing.TypeVar('_List__Set__SimpleUnionT', bound=_typing.Sequence[_typing.AbstractSet['SimpleUnion']])


class List__Set__SimpleUnion(_typing.Sequence[_typing.AbstractSet['SimpleUnion']], _typing.Hashable):
    def __init__(self, items: _typing.Sequence[_typing.AbstractSet['SimpleUnion']]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Sequence[_typing.AbstractSet['SimpleUnion']]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> _typing.AbstractSet['SimpleUnion']: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[_typing.AbstractSet['SimpleUnion']]: ...
    def count(self, item: _typing.Any) -> int: ...
    def index(self, item: _typing.Any, start: int = ..., stop: int = ...) -> int: ...
    def __add__(self, other: _typing.Sequence[_typing.AbstractSet['SimpleUnion']]) -> 'List__Set__SimpleUnion': ...
    def __radd__(self, other: _List__Set__SimpleUnionT) -> _List__Set__SimpleUnionT: ...
    def __reversed__(self) -> _typing.Iterator[_typing.AbstractSet['SimpleUnion']]: ...
    def __iter__(self) -> _typing.Iterator[_typing.AbstractSet['SimpleUnion']]: ...


class Map__string_bool(_typing.Mapping[str, bool], _typing.Hashable):
    def __init__(self, items: _typing.Mapping[str, bool]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Mapping[str, bool]: ...
    def __getitem__(self, key: str) -> bool: ...
    def __iter__(self) -> _typing.Iterator[str]: ...


class Set__i32(_typing.AbstractSet[int], _typing.Hashable):
    def __init__(self, items: _typing.AbstractSet[int]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.AbstractSet[int]: ...
    def isdisjoint(self, other: _typing.AbstractSet[int]) -> bool: ...
    def union(self, other: _typing.AbstractSet[int]) -> 'Set__i32': ...
    def intersection(self, other: _typing.AbstractSet[int]) -> 'Set__i32': ...
    def difference(self, other: _typing.AbstractSet[int]) -> 'Set__i32': ...
    def symmetric_difference(self, other: _typing.AbstractSet[int]) -> 'Set__i32': ...
    def issubset(self, other: _typing.AbstractSet[int]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[int]) -> bool: ...
    def __iter__(self) -> _typing.Iterator[int]: ...


class Map__string_Map__string_i32(_typing.Mapping[str, _typing.Mapping[str, int]], _typing.Hashable):
    def __init__(self, items: _typing.Mapping[str, _typing.Mapping[str, int]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Mapping[str, _typing.Mapping[str, int]]: ...
    def __getitem__(self, key: str) -> _typing.Mapping[str, int]: ...
    def __iter__(self) -> _typing.Iterator[str]: ...


class Map__string_Map__string_Map__string_i32(_typing.Mapping[str, _typing.Mapping[str, _typing.Mapping[str, int]]], _typing.Hashable):
    def __init__(self, items: _typing.Mapping[str, _typing.Mapping[str, _typing.Mapping[str, int]]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Mapping[str, _typing.Mapping[str, _typing.Mapping[str, int]]]: ...
    def __getitem__(self, key: str) -> _typing.Mapping[str, _typing.Mapping[str, int]]: ...
    def __iter__(self) -> _typing.Iterator[str]: ...


_List__Set__i32T = _typing.TypeVar('_List__Set__i32T', bound=_typing.Sequence[_typing.AbstractSet[int]])


class List__Set__i32(_typing.Sequence[_typing.AbstractSet[int]], _typing.Hashable):
    def __init__(self, items: _typing.Sequence[_typing.AbstractSet[int]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Sequence[_typing.AbstractSet[int]]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> _typing.AbstractSet[int]: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[_typing.AbstractSet[int]]: ...
    def count(self, item: _typing.Any) -> int: ...
    def index(self, item: _typing.Any, start: int = ..., stop: int = ...) -> int: ...
    def __add__(self, other: _typing.Sequence[_typing.AbstractSet[int]]) -> 'List__Set__i32': ...
    def __radd__(self, other: _List__Set__i32T) -> _List__Set__i32T: ...
    def __reversed__(self) -> _typing.Iterator[_typing.AbstractSet[int]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.AbstractSet[int]]: ...


class Map__string_List__i32(_typing.Mapping[str, _typing.Sequence[int]], _typing.Hashable):
    def __init__(self, items: _typing.Mapping[str, _typing.Sequence[int]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Mapping[str, _typing.Sequence[int]]: ...
    def __getitem__(self, key: str) -> _typing.Sequence[int]: ...
    def __iter__(self) -> _typing.Iterator[str]: ...


class Set__bool(_typing.AbstractSet[bool], _typing.Hashable):
    def __init__(self, items: _typing.AbstractSet[bool]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.AbstractSet[bool]: ...
    def isdisjoint(self, other: _typing.AbstractSet[bool]) -> bool: ...
    def union(self, other: _typing.AbstractSet[bool]) -> 'Set__bool': ...
    def intersection(self, other: _typing.AbstractSet[bool]) -> 'Set__bool': ...
    def difference(self, other: _typing.AbstractSet[bool]) -> 'Set__bool': ...
    def symmetric_difference(self, other: _typing.AbstractSet[bool]) -> 'Set__bool': ...
    def issubset(self, other: _typing.AbstractSet[bool]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[bool]) -> bool: ...
    def __iter__(self) -> _typing.Iterator[bool]: ...


class Set__Set__bool(_typing.AbstractSet[_typing.AbstractSet[bool]], _typing.Hashable):
    def __init__(self, items: _typing.AbstractSet[_typing.AbstractSet[bool]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.AbstractSet[_typing.AbstractSet[bool]]: ...
    def isdisjoint(self, other: _typing.AbstractSet[_typing.AbstractSet[bool]]) -> bool: ...
    def union(self, other: _typing.AbstractSet[_typing.AbstractSet[bool]]) -> 'Set__Set__bool': ...
    def intersection(self, other: _typing.AbstractSet[_typing.AbstractSet[bool]]) -> 'Set__Set__bool': ...
    def difference(self, other: _typing.AbstractSet[_typing.AbstractSet[bool]]) -> 'Set__Set__bool': ...
    def symmetric_difference(self, other: _typing.AbstractSet[_typing.AbstractSet[bool]]) -> 'Set__Set__bool': ...
    def issubset(self, other: _typing.AbstractSet[_typing.AbstractSet[bool]]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[_typing.AbstractSet[bool]]) -> bool: ...
    def __iter__(self) -> _typing.Iterator[_typing.AbstractSet[bool]]: ...


class Set__Set__Set__bool(_typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]], _typing.Hashable):
    def __init__(self, items: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]: ...
    def isdisjoint(self, other: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]) -> bool: ...
    def union(self, other: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]) -> 'Set__Set__Set__bool': ...
    def intersection(self, other: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]) -> 'Set__Set__Set__bool': ...
    def difference(self, other: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]) -> 'Set__Set__Set__bool': ...
    def symmetric_difference(self, other: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]) -> 'Set__Set__Set__bool': ...
    def issubset(self, other: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]) -> bool: ...
    def __iter__(self) -> _typing.Iterator[_typing.AbstractSet[_typing.AbstractSet[bool]]]: ...


class Map__Bar__double_Baz__i32(_typing.Mapping[float, int], _typing.Hashable):
    def __init__(self, items: _typing.Mapping[float, int]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Mapping[float, int]: ...
    def __getitem__(self, key: float) -> int: ...
    def __iter__(self) -> _typing.Iterator[float]: ...


_folly_small_vector_int64_t_8__List__i64T = _typing.TypeVar('_folly_small_vector_int64_t_8__List__i64T', bound=_typing.Sequence[int])


class folly_small_vector_int64_t_8__List__i64(_typing.Sequence[int], _typing.Hashable):
    def __init__(self, items: _typing.Sequence[int]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Sequence[int]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> int: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[int]: ...
    def count(self, item: _typing.Any) -> int: ...
    def index(self, item: _typing.Any, start: int = ..., stop: int = ...) -> int: ...
    def __add__(self, other: _typing.Sequence[int]) -> 'folly_small_vector_int64_t_8__List__i64': ...
    def __radd__(self, other: _folly_small_vector_int64_t_8__List__i64T) -> _folly_small_vector_int64_t_8__List__i64T: ...
    def __reversed__(self) -> _typing.Iterator[int]: ...
    def __iter__(self) -> _typing.Iterator[int]: ...


class folly_sorted_vector_set_std_string__Set__string(_typing.AbstractSet[str], _typing.Hashable):
    def __init__(self, items: _typing.AbstractSet[str]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.AbstractSet[str]: ...
    def isdisjoint(self, other: _typing.AbstractSet[str]) -> bool: ...
    def union(self, other: _typing.AbstractSet[str]) -> 'folly_sorted_vector_set_std_string__Set__string': ...
    def intersection(self, other: _typing.AbstractSet[str]) -> 'folly_sorted_vector_set_std_string__Set__string': ...
    def difference(self, other: _typing.AbstractSet[str]) -> 'folly_sorted_vector_set_std_string__Set__string': ...
    def symmetric_difference(self, other: _typing.AbstractSet[str]) -> 'folly_sorted_vector_set_std_string__Set__string': ...
    def issubset(self, other: _typing.AbstractSet[str]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[str]) -> bool: ...
    def __iter__(self) -> _typing.Iterator[str]: ...


class FakeMap__Map__i64_double(_typing.Mapping[int, float], _typing.Hashable):
    def __init__(self, items: _typing.Mapping[int, float]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Mapping[int, float]: ...
    def __getitem__(self, key: int) -> float: ...
    def __iter__(self) -> _typing.Iterator[int]: ...


class std_unordered_map_std_string_containerStruct__Map__string_containerStruct(_typing.Mapping[str, 'containerStruct'], _typing.Hashable):
    def __init__(self, items: _typing.Mapping[str, 'containerStruct']=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Mapping[str, 'containerStruct']: ...
    def __getitem__(self, key: str) -> 'containerStruct': ...
    def __iter__(self) -> _typing.Iterator[str]: ...


_std_list__List__i32T = _typing.TypeVar('_std_list__List__i32T', bound=_typing.Sequence[int])


class std_list__List__i32(_typing.Sequence[int], _typing.Hashable):
    def __init__(self, items: _typing.Sequence[int]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Sequence[int]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> int: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[int]: ...
    def count(self, item: _typing.Any) -> int: ...
    def index(self, item: _typing.Any, start: int = ..., stop: int = ...) -> int: ...
    def __add__(self, other: _typing.Sequence[int]) -> 'std_list__List__i32': ...
    def __radd__(self, other: _std_list__List__i32T) -> _std_list__List__i32T: ...
    def __reversed__(self) -> _typing.Iterator[int]: ...
    def __iter__(self) -> _typing.Iterator[int]: ...


_std_deque__List__stringT = _typing.TypeVar('_std_deque__List__stringT', bound=_typing.Sequence[str])


class std_deque__List__string(_typing.Sequence[str], _typing.Hashable):
    def __init__(self, items: _typing.Sequence[str]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Sequence[str]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> str: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[str]: ...
    def count(self, item: _typing.Any) -> int: ...
    def index(self, item: _typing.Any, start: int = ..., stop: int = ...) -> int: ...
    def __add__(self, other: _typing.Sequence[str]) -> 'std_deque__List__string': ...
    def __radd__(self, other: _std_deque__List__stringT) -> _std_deque__List__stringT: ...
    def __reversed__(self) -> _typing.Iterator[str]: ...
    def __iter__(self) -> _typing.Iterator[str]: ...


class folly_sorted_vector_set__Set__string(_typing.AbstractSet[str], _typing.Hashable):
    def __init__(self, items: _typing.AbstractSet[str]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.AbstractSet[str]: ...
    def isdisjoint(self, other: _typing.AbstractSet[str]) -> bool: ...
    def union(self, other: _typing.AbstractSet[str]) -> 'folly_sorted_vector_set__Set__string': ...
    def intersection(self, other: _typing.AbstractSet[str]) -> 'folly_sorted_vector_set__Set__string': ...
    def difference(self, other: _typing.AbstractSet[str]) -> 'folly_sorted_vector_set__Set__string': ...
    def symmetric_difference(self, other: _typing.AbstractSet[str]) -> 'folly_sorted_vector_set__Set__string': ...
    def issubset(self, other: _typing.AbstractSet[str]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[str]) -> bool: ...
    def __iter__(self) -> _typing.Iterator[str]: ...


class folly_sorted_vector_map__Map__i64_string(_typing.Mapping[int, str], _typing.Hashable):
    def __init__(self, items: _typing.Mapping[int, str]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Mapping[int, str]: ...
    def __getitem__(self, key: int) -> str: ...
    def __iter__(self) -> _typing.Iterator[int]: ...


_List__Bar__doubleT = _typing.TypeVar('_List__Bar__doubleT', bound=_typing.Sequence[float])


class List__Bar__double(_typing.Sequence[float], _typing.Hashable):
    def __init__(self, items: _typing.Sequence[float]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Sequence[float]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> float: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[float]: ...
    def count(self, item: _typing.Any) -> int: ...
    def index(self, item: _typing.Any, start: int = ..., stop: int = ...) -> int: ...
    def __add__(self, other: _typing.Sequence[float]) -> 'List__Bar__double': ...
    def __radd__(self, other: _List__Bar__doubleT) -> _List__Bar__doubleT: ...
    def __reversed__(self) -> _typing.Iterator[float]: ...
    def __iter__(self) -> _typing.Iterator[float]: ...


class Set__Baz__i32(_typing.AbstractSet[int], _typing.Hashable):
    def __init__(self, items: _typing.AbstractSet[int]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.AbstractSet[int]: ...
    def isdisjoint(self, other: _typing.AbstractSet[int]) -> bool: ...
    def union(self, other: _typing.AbstractSet[int]) -> 'Set__Baz__i32': ...
    def intersection(self, other: _typing.AbstractSet[int]) -> 'Set__Baz__i32': ...
    def difference(self, other: _typing.AbstractSet[int]) -> 'Set__Baz__i32': ...
    def symmetric_difference(self, other: _typing.AbstractSet[int]) -> 'Set__Baz__i32': ...
    def issubset(self, other: _typing.AbstractSet[int]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[int]) -> bool: ...
    def __iter__(self) -> _typing.Iterator[int]: ...


class Map__string_folly_IOBuf__binary(_typing.Mapping[str, __iobuf.IOBuf], _typing.Hashable):
    def __init__(self, items: _typing.Mapping[str, __iobuf.IOBuf]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Mapping[str, __iobuf.IOBuf]: ...
    def __getitem__(self, key: str) -> __iobuf.IOBuf: ...
    def __iter__(self) -> _typing.Iterator[str]: ...


class Map__string_std_unique_ptr_folly_IOBuf__binary(_typing.Mapping[str, __iobuf.IOBuf], _typing.Hashable):
    def __init__(self, items: _typing.Mapping[str, __iobuf.IOBuf]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Mapping[str, __iobuf.IOBuf]: ...
    def __getitem__(self, key: str) -> __iobuf.IOBuf: ...
    def __iter__(self) -> _typing.Iterator[str]: ...


class Map__i32_string(_typing.Mapping[int, str], _typing.Hashable):
    def __init__(self, items: _typing.Mapping[int, str]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Mapping[int, str]: ...
    def __getitem__(self, key: int) -> str: ...
    def __iter__(self) -> _typing.Iterator[int]: ...


_List__Map__string_i32T = _typing.TypeVar('_List__Map__string_i32T', bound=_typing.Sequence[_typing.Mapping[str, int]])


class List__Map__string_i32(_typing.Sequence[_typing.Mapping[str, int]], _typing.Hashable):
    def __init__(self, items: _typing.Sequence[_typing.Mapping[str, int]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Sequence[_typing.Mapping[str, int]]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> _typing.Mapping[str, int]: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[_typing.Mapping[str, int]]: ...
    def count(self, item: _typing.Any) -> int: ...
    def index(self, item: _typing.Any, start: int = ..., stop: int = ...) -> int: ...
    def __add__(self, other: _typing.Sequence[_typing.Mapping[str, int]]) -> 'List__Map__string_i32': ...
    def __radd__(self, other: _List__Map__string_i32T) -> _List__Map__string_i32T: ...
    def __reversed__(self) -> _typing.Iterator[_typing.Mapping[str, int]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Mapping[str, int]]: ...


class Map__i16_string(_typing.Mapping[int, str], _typing.Hashable):
    def __init__(self, items: _typing.Mapping[int, str]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Mapping[int, str]: ...
    def __getitem__(self, key: int) -> str: ...
    def __iter__(self) -> _typing.Iterator[int]: ...


_List__Map__i16_stringT = _typing.TypeVar('_List__Map__i16_stringT', bound=_typing.Sequence[_typing.Mapping[int, str]])


class List__Map__i16_string(_typing.Sequence[_typing.Mapping[int, str]], _typing.Hashable):
    def __init__(self, items: _typing.Sequence[_typing.Mapping[int, str]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Sequence[_typing.Mapping[int, str]]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> _typing.Mapping[int, str]: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[_typing.Mapping[int, str]]: ...
    def count(self, item: _typing.Any) -> int: ...
    def index(self, item: _typing.Any, start: int = ..., stop: int = ...) -> int: ...
    def __add__(self, other: _typing.Sequence[_typing.Mapping[int, str]]) -> 'List__Map__i16_string': ...
    def __radd__(self, other: _List__Map__i16_stringT) -> _List__Map__i16_stringT: ...
    def __reversed__(self) -> _typing.Iterator[_typing.Mapping[int, str]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Mapping[int, str]]: ...


_List__MyStructT = _typing.TypeVar('_List__MyStructT', bound=_typing.Sequence['MyStruct'])


class List__MyStruct(_typing.Sequence['MyStruct'], _typing.Hashable):
    def __init__(self, items: _typing.Sequence['MyStruct']=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __contains__(self, x: object) -> bool: ...
    def __copy__(self) -> _typing.Sequence['MyStruct']: ...
    @_typing.overload
    def __getitem__(self, i: int) -> 'MyStruct': ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence['MyStruct']: ...
    def count(self, item: _typing.Any) -> int: ...
    def index(self, item: _typing.Any, start: int = ..., stop: int = ...) -> int: ...
    def __add__(self, other: _typing.Sequence['MyStruct']) -> 'List__MyStruct': ...
    def __radd__(self, other: _List__MyStructT) -> _List__MyStructT: ...
    def __reversed__(self) -> _typing.Iterator['MyStruct']: ...
    def __iter__(self) -> _typing.Iterator['MyStruct']: ...


aBool: bool = ...
aByte: int = ...
a16BitInt: int = ...
a32BitInt: int = ...
a64BitInt: int = ...
aFloat: float = ...
aDouble: float = ...
aString: str = ...
aList: List__bool = ...
anEmptyMap: Map__string_i32 = ...
aMap: Map__i32_string = ...
aSet: Set__string = ...
aListOfLists: List__List__i32 = ...
states: List__Map__string_i32 = ...
AConstList: List__MyEnumA = ...
AnIntegerEnum2: int = ...
AnIntegerEnum2: List__i32 = ...
constEnumA: MyEnumA = ...
constEnumB: MyEnumA = ...
AStruct = _includes_types.AStruct
simpleTypeDef = int
containerTypeDef = Map__i16_string
complexContainerTypeDef = List__Map__i16_string
unionTypeDef = Set__SimpleUnion
structTypeDef = List__MyStruct
complexStructTypeDef = List__Map__Empty_MyStruct
mostComplexTypeDef = List__List__Map__Empty_MyStruct
IndirectionA = int
IndirectionC = int
IndirectionB = float
IndirectionD = str
HashedTypedef = Map__MyEnumA_string
CppFakeI32 = int
FollySmallVectorI64 = folly_small_vector_int64_t_8__List__i64
SortedVectorSetString = folly_sorted_vector_set_std_string__Set__string
FakeMap = FakeMap__Map__i64_double
UnorderedMapStruct = std_unordered_map_std_string_containerStruct__Map__string_containerStruct
std_list = std_list__List__i32
std_deque = std_deque__List__string
folly_set = folly_sorted_vector_set__Set__string
folly_map = folly_sorted_vector_map__Map__i64_string
IOBuf = __iobuf.IOBuf
IOBufPtr = __iobuf.IOBuf
